## 生成短網址背後的演算法
可以利用hash算法達到短網址的實作
### 理論背景
從功能上來看，短網址服務實際上非常簡單，就是將一個長的網址轉換成一個短的網址。作為一名軟體工程師，你是否思考過，這樣一個簡單的功能是如何實現的呢？底層都依賴了哪些數據結構和算法呢。
#### 短網址服務流程
![image](https://github.com/patrick0516/alg112a/assets/109636871/cc89f041-a253-439f-b65e-c1a146c5f1de)
#### 通過哈希表生成短網址
我們前面學過哈希算法。哈希算法可以將一個不管多長的字符串，轉換成一個長度固定的哈希值。我們可以利用哈希算法，來生成短網址。
前面我們已經提過一些哈希算法了，比如 MD5、SHA 等。但是，實際上，我們並不需要這些複雜的哈希算法。在生成短網址這個問題上，畢竟，我們不需要考慮反向解密的難度，所以我們只需要關心哈希算法的計算速度和衝突概率。
能夠滿足這樣要求的哈希算法有很多，其中比較著名並且應用廣泛的一個哈希算法，那就是 MurmurHash 算法。儘管這個哈希算法在 2008 年才被發明出來，但現在它已經廣泛應用到 Redis、MemCache、Cassandra、HBase、Lucene 等眾多著名的軟體中。
MurmurHash 算法提供了兩種長度的哈希值，一種是 32bits，一種是 128bits。為了讓最終生成的短網址尽可能短，我們可以選擇 32bits 的哈希值。對於開頭那個 GitHub 網址，經過 MurmurHash 計算後，得到的哈希值就是 181338494。我們再拼上短網址服務的域名，就變成了最終的短網址 http://t.cn/181338494（其中，http://t.cn 是短網址服務的域名）。
#### 如何讓短網址更短
我們可以將10進制的哈希值轉換成更高進制的哈希值，這樣哈希值就變短了。我們知道，在16進制中，我們用A～F表示10～15。在網址URL中，常用的合法字符有0～9、a～z、A～Z這樣62個字符。為了讓哈希值表示起來尽可能短，我們可以將10進制的哈希值轉換成62進制。具體的計算過程，我寫在這裡了。最終用62進制表示的短網址就是http://t.cn/cgSqq。
![image](https://github.com/patrick0516/alg112a/assets/109636871/255c9c38-bf48-4788-b29d-d5383c10ace8)

#### 如何優化哈希生成短網址的效能
為了判斷生成的短網址是否衝突，我們可以給資料庫中的短網址欄位添加唯一索引。這樣，在儲存新生成的短網址時，直接嘗試儲存，如果成功則沒有衝突，否則違反唯一性索引，需要重新執行查詢和寫入過程。通過這種方式，可以減少大部分情況下的SQL執行次數，提高性能。

另外，借助布隆過濾器，將已生成的短網址構建成布隆過濾器，先在過濾器中查找新生成的短網址是否存在，不存在則執行寫入操作。這樣可以再次減少SQL語句的執行次數。

#### 如何通過ID生成器生成短網址
我们可以維護一個 ID 自增生成器。它可以生成 1、2、3… 這樣自增的整數 ID。當短網址服務接收到一個原始網址轉化成短網址的請求之後，它先從 ID 生成器中取一個號碼，然後將其轉化成 62 進制表示法，拼接到短網址服務的域名（例如 http://t.cn/）後面，就形成了最終的短網址。最後，我們還是會把生成的短網址和對應的原始網址存儲到數據庫中。
理論非常簡單好理解。不過，這裡有幾個細節問題需要處理。

##### 相同原始網址可能會對應不同短網址
每次新增一個原始網址時，生成一個新的短網址可能導致相同的原始網址對應不同的短網址。有兩種處理思路：

1. **不做處理**： 允許相同的原始網址對應不同的短網址。在大多數短網址應用中，使用者通常只關心短網址是否能正確跳轉到原始網址，而不太在乎短網址的具體形式。因此，即使是相同的原始網址生成的短網址不同，對使用者使用並不會有影響。

2. **利用哈希算法生成短網址**： 在生成短網址之前，先在資料庫中查找原始網址是否已經存在。如果存在，直接返回對應的短網址。這種方法滿足“相同原始網址對應相同短網址”的需求，但需要給資料庫中的短網址和原始網址兩個欄位都添加索引。這樣雖然解決了問題，但代價是兩個索引佔用更多存儲空間，並且可能導致插入、刪除等操作性能下降。

##### 如何實現高效能的ID生成器
實現 ID 生成器的方法有很多，例如利用數據庫自增字段。當然我們也可以自己維護一個計數器，不停地加一。但是，一個計數器來應對頻繁的短網址生成請求，顯然是有點吃力的（因為計數器必須保證生成的 ID 不重複，簡單概念上講，就是需要加鎖）。如何提高 ID 生成器的性能呢？關於這個問題，實際上，有很多解決思路。我這裡給出兩種思路。

第一種思路是借助第 54 節中講的方法。我們可以給 ID 生成器裝多個前置發號器。我們批量地給每個前置發號器發送 ID 號碼。當我們接受到短網址生成請求的時候，就選擇一個前置發號器來取號碼。這樣通過多個前置發號器，明顯提高了並發發號的能力。
![image](https://github.com/patrick0516/alg112a/assets/109636871/46cb6f48-6347-483d-b95c-8865605fcef4)

第二種思路跟第一種差不多。不過，我們不再使用一個 ID 生成器和多個前置發號器這樣的架構，而是，直接實現多個 ID 生成器同時服務。為了保證每個 ID 生成器生成的 ID 不重複。我們要求每個 ID 生成器按照一定的規則，來生成 ID 號碼。比如，第一個 ID 生成器只能生成尾號為 0 的，第二個只能生成尾號為 1 的，以此類推。這樣通過多個 ID 生成器同時工作，也提高了 ID 生成的效率。
![image](https://github.com/patrick0516/alg112a/assets/109636871/e38fab9c-e5f3-4445-9def-db842600ae7d)


#### 總結
結合以上理論，搭配實作製作短網址轉換器。

### shorturl.py
設計算法功能

### storage.py
儲存

### app.py
提供生成的接口

### 備註
參考自極客時間: 數據結構與算法之美，我摘錄重點，建議觀看原文。
